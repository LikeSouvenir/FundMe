## Fund Me
###Материал с https://github.com/fullstack-development/solidity-developer-roadmap/blob/main/junior-1/README.md

- Необходимо пройти [Lesson 4: Remix Fund Me](https://github.com/smartcontractkit/full-blockchain-solidity-course-js#lesson-4-remix-fund-me), обязательно повторить функционал из урока - т.е самостоятельно написать контракт который будет иметь функционал для депозита и вывода эфира, а также будет производить проверку и отклонять транзакцию если количество переданного эфира по стоимости меньше $25.

## Вопросы по теории

1. Какие данные попадают в транзакцию при отправке эфира? Какие поля там будут?
---
    block.number, msg.sender/tx.origin, msg.vvalue, block.timestamp, hashCode, code функции, nonce, селектор функции, входные параметры, 
---
2. Зачем нужна переменная `msg.value`? Какие еще существуют глобальные переменные?
---
    хранит кол-во эфира, в wei отправленное в транзакцию. Выше 
---
3. За что отвечают поля `inputs` и `outputs` в ABI функции?
---
    входные и выходные параметры
---
4. Какой модификатор обязателен для функции принимающей эфир? Как переменную типа `address` переопределить, чтобы можно было отправить эфир с этого адреса?
---
    payable. payable(address(this)) payable(msg.sender)
---
5. Что произойдет если перед тем как транзакция ревертится мы успеем сделать запись в переменную из `storage`?
---
    откат
---
6. Когда `view` функцию вызывает другой контракт это стоит газа или нет?
---
    да
---
7. Как работать с числами с плавающей точкой в solidity? Что такое `decimals`? Для чего нужен `decimals` при расчете цен токенов?
---
    Чисел с палвающей точкой нет, есть decimals, отвечающий за ко-во знаков после запятой. Есть так же ufixed и fixed
---
9. Зачем в функции `getPrice`  при получении значения `answer` запятые перед и после значения? Как ты объяснишь запись `uint256(answer * 10000000000)`?
```js
    function getPrice() internal view returns (uint256) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(
            0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        );
        (, int256 answer, , , ) = priceFeed.latestRoundData();

        return uint256(answer * 10000000000);
    }
```
---
    получения текущей стоимости 1 eth за usd. Запятые - это пропущеные возвращаемые значения из функции.
    Домножение нужно т.к. адрес возвращает число с длинной в 8 знаков, и его нужно домножить до кол-во знаков в эфире
---
9. Как сбросить все значения массива?
---
    delete
---
11. Рассказать про три способа отправки эфира. Какой способ предпочтительный и почему? Как и зачем предавать данные в `call`?
---
    transfer - ограничение в 2300 газа, revert в случае ошибки 
    send - ограничение в 2300 газа, returns false в случае ошибки
    call - низкоуроввый вызов, returns false в случае ошибки, можем указывать кол-во отправляемого gas и value
    (bool success, bytes data) = payable(address).call{gas:... value...}("...");
---
13. Посмотри код ниже, объясни что тут происходит. Что означает запись `address(this).balance`?
```js
    (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}("");
    require(callSuccess, "Call failed");
```
---
    перевод баланса контракта на вызывающий адрес, и в случае ошибки revert
---
12. Как написать кастомный модификатор? Может ли кастомный модификатор принимать аргументы? Можно ли писать код в модификаторе после `_;`?
---
    ключевое слово modifier
    да, может
    да, можно
---
14. Для чего нужны `receive`гште и `fallback`? Когда их нужно использовать? Что будет если мы отправим эфир на контракт но там не будет этих функций? Как связаны `msg.data` и `fallback`?
---
    для обработки отправки эфира на контракт
    recive - в выполняется при отправки без аргументов, fallback - с аргументами(msg.data)
    Без этих функций контракт не примет эфир
    * Контракт может принять эфир, если есть явно созданные функции payable и вызывающий обращается к именно к ним
---
15. Что такое оракулы? Какую проблему они решают? Для чего используются кроме получения цены токенов?
---
    Оракул - программа агрегирующая данные из внешнего мира и отправляющая их в блокчейн. Блокчей является детерминированной 
    программой, а значит всегда должен выдавать один и тот же результат с теми же входными данными(синхронизация узлов)
    Они и решаю проблему закрытости блокчейна
    Для получения любой внешний информации - цены, предсказания, страхование, погода, iot...
---

